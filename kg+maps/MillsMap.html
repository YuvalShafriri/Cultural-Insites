<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>מפת טחנות — טעינה אוטומטית מ־mills_data.json</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet & plugins CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #map { height: 100%; width: 100%; }
    .leaflet-control-layers-expanded { direction: ltr; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet & plugins JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // ——— פונקציות עזר ———
    function firstPointInGeometry(geom){
      if(!geom) return null;
      const t = geom.type;
      if(t === 'Point') return geom.coordinates.slice();
      if(t === 'MultiPoint' && geom.coordinates.length) return geom.coordinates[0].slice();
      if(t === 'GeometryCollection' && Array.isArray(geom.geometries)){
        const pt = geom.geometries.find(g => g.type === 'Point');
        if(pt) return pt.coordinates.slice();
        try { const c = turf.centroid(geom); return c.geometry.coordinates.slice(); } catch(e){ return null; }
      }
      try { const c = turf.centroid(geom); return c.geometry.coordinates.slice(); } catch(e){ return null; }
    }

    function featureCentroidLatLng(f){
      const coord = firstPointInGeometry(f.geometry);
      if(!coord) return null;
      return [coord[1], coord[0]]; // [lat,lng]
    }

    function explodePolygonsToLatLngs(f){
      const g = f.geometry; if(!g) return [];
      const rings = [];
      const toLatLng = arr => arr.map(([x,y]) => [y,x]);
      if(g.type === 'Polygon') rings.push(toLatLng(g.coordinates[0]));
      else if(g.type === 'MultiPolygon') g.coordinates.forEach(poly => rings.push(toLatLng(poly[0])));
      else if(g.type === 'GeometryCollection'){
        g.geometries.forEach(gg => {
          if(gg.type === 'Polygon') rings.push(toLatLng(gg.coordinates[0]));
          if(gg.type === 'MultiPolygon') gg.coordinates.forEach(poly => rings.push(toLatLng(poly[0])));
        });
      }
      return rings;
    }

    function renderAll(data){
      const map = L.map('map');
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);
      const clusterLayer = L.markerClusterGroup();
      // Heatmap חזק יותר: רדיוס גדול יותר, טשטוש נמוך יותר וגרדיאנט "חם"
      const heatLayer = L.heatLayer([], {
        radius: 34,
        blur: 12,
        max: 1.0,
        // גרדיאנט עז
        gradient: {
          0.00: '#0015ff',   // כחול עז
          0.35: '#00e5ff',   // טורקיז
          0.60: '#00ff66',   // ירוק-ליים
          0.80: '#ffee00',   // צהוב
          1.00: '#ff2200'    // אדום חזק
        }
      });
      const polygonsLayer = L.layerGroup();

      L.control.layers(
        { 'OpenStreetMap': osm },
        { 'Clusters': clusterLayer, 'Heatmap': heatLayer, 'Polygons (optional)': polygonsLayer },
        { collapsed: false }
      ).addTo(map);

      const feats = Array.isArray(data) ? data : (data.features || []);
      const pts = [];

      feats.forEach(f => {
        const name = f.properties?.Name || f.properties?.name || f.name || 'Mill';
        const latlng = featureCentroidLatLng(f);
        if(latlng){
          const mk = L.marker(latlng).bindPopup(`<strong>${name}</strong>`);
          clusterLayer.addLayer(mk);
          // Intensity מלאה (1.0) כדי לחזק את ההיטמאפ
          heatLayer.addLatLng([latlng[0], latlng[1], 1.0]);
          pts.push(latlng);
        }
        // קווי מתאר לפוליגונים (אופציונלי)
        explodePolygonsToLatLngs(f).forEach(ring => {
          L.polygon(ring, { color:'#2563eb', weight: 2, fillOpacity: 0.10 }).addTo(polygonsLayer);
        });
      });

      if(pts.length){
        const b = L.latLngBounds(pts);
        map.fitBounds(b.pad(0.2));
      } else {
        map.setView([32.1, 34.9], 8);
      }

      map.addLayer(clusterLayer);
      map.addLayer(heatLayer);
      map.addLayer(polygonsLayer);
    }

    // ——— טעינה אוטומטית של mills_data.json (חייב להיות לצד קובץ ה‑HTML) ———
    // שים לב: דפדפנים מסוימים חוסמים fetch מ־file://. מומלץ לפתוח עם שרת מקומי פשוט.
    fetch('./mills-data.json')
      .then(r => {
        if(!r.ok) throw new Error('לא ניתן לטעון mills_data.json');
        return r.json();
      })
      .then(json => renderAll(json))
      .catch(err => {
        console.error(err);
        alert('טעינת mills_data.json נכשלה. ודאו שהקובץ נמצא באותה תיקייה של ה‑HTML ושהדפדפן מאפשר טעינה מקובץ מקומי.');
      });
  </script>
</body>
</html>
